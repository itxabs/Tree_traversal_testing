#include <iostream>
using namespace std;
class Node
{
public:
    int key;
    Node *right;
    Node *left;
Node(int data)
{
    key = data;
    left = NULL;
    right = NULL;
}
};
class Queue
{
private:
  Node* front;
  Node* rear;
  Node* next;
  int size=10;
  Node *Q[10];
public:
  Queue()
{
  front = NULL;
  rear = NULL;
}
 // void EnQueue(Node *x)
 //  {
 //    if (Isfull())
 //    {
 //      cout << "Queue is full:";
 //    }
 //    if (front == -1) 
 //    {
 //          front = 0;
 //    }
 //    else  
 //    Q[++rear] = x;
 //  }

void enQueue(Node* x)
{

    // Create a new LL node
    Node* temp = new Node(x);

    // If queue is empty, then
    // new node is front and rear both
    if (rear == NULL) {
        front = rear = temp;
        return;
    }

    // Add the new node at
    // the end of queue and change rear
    rear->right = temp;
    rear = temp;
    rear->right= NULL;
}
  // Node* deQueue()
  // {
  //   if (IsEmtpy()) 
  //   {
  //     cout << "Queue is empty." << endl;
  //     return 0;
  //   }
  //   else 
  //   {
  //     front++;
  //     return Q[front];
  //   }
  // }

Node* deQueue()
{
    // If queue is empty, return NULL.
    if (front == NULL)
        return NULL;

    // Store previous front and
    // move front one node ahead
    Node* temp = front;
    front = front->right;

    // If front becomes NULL, then
    // change rear also as NULL
    if (front == NULL)
        rear = NULL;

  cout<<"Dequeued element is: "<<temp->key<<endl;
    delete (temp);
}
  // bool Isfull()
  // {
  // return rear == size - 1;
  // }
  bool IsEmtpy()
  {
    return front = NULL;
  }
  // Node* getFront() {
  //   if (IsEmtpy()) {
  //     cout << "Queue is empty." << endl;
  //     return NULL;
  //   }
  //   else {
  //     return Q[front];
  //   }
  // }
  
};
class Bt
{
public:
Node* root;
Bt()
{  root=NULL; }

void Inorder(Node* root)
{
  if(root!=NULL)
  {
    Inorder(root->left);
    cout<<root->key<<" ";
    Inorder(root->right);
    
  }
}
void Preorder(Node* root)
{
  if(root!=NULL)
  {
    cout<<root->key<<" ";
    Preorder(root->left);
    Preorder(root->right);

  }
}
void Postorder(Node* root)
{
  if(root!=NULL)
  {
    Postorder(root->left);
    Postorder(root->right);
    cout<<root->key<<" ";
  }
}

void Levelwise(Node* root)
{

  if(root==NULL)
  {
    return ;
  }
  Queue q;
    q.enQueue(root);
    while(q.IsEmtpy()== false)
      {
        Node* curr = q.deQueue();
        
        cout<<curr->key<<" ";
        if(curr->left!=NULL)
        {
          q.enQueue(curr->left);
        }
        if(curr->right!=NULL)
        {
          q.enQueue(curr->right);
        }
      }
}

// void Levelwise(Node* root)
// {
//   if (root == NULL)
//   {
//     return;
//   }
//   Queue q;
//   q.EnQueue(root);
//   while (!q.IsEmtpy())
//   {
//     Node* curr = q.getFront();
//     q.deQueue();  // Move the dequeue operation after getting the front

//     // Check if curr is NULL before accessing its key
//     if (curr != NULL) {
//       cout << curr->key << " ";
//       if (curr->left != NULL)
//       {
//         q.EnQueue(curr->left);
//       }
//       if (curr->right != NULL)
//       {
//         q.EnQueue(curr->right);
//       }
//     }
//   }
// }


};
int main()
{


  Bt tree;
  tree.root=new Node(10);
  tree.root->left=new Node(20);
  tree.root->right=new Node(30);
  tree.root->right->left=new Node(40);
  tree.root->right->right=new Node(50);

  tree.Preorder(tree.root);
  cout<<"\n"<<endl;
  tree.Postorder(tree.root);
  cout<<"\n"<<endl;
  tree.Inorder(tree.root);
  cout<<"\n"<<endl;
  cout<<"Line wise"<<endl;
  tree.Levelwise(tree.root);
  return 0;
}
